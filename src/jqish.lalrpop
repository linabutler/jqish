// Copyright (c) 2025 Lina Butler
// SPDX-License-Identifier: Apache-2.0 OR MIT

//! A LALRPOP grammar for the `jqish` language.

use lalrpop_util::ParseError;

use crate::{
    error::{SpannedError, LexicalError},
    lexer::Token,
    parser::{unquote, Expr, Number, Int},
};

grammar<'input>(text: &'input str);

extern {
    type Location = usize;
    type Error = SpannedError<LexicalError>;

    enum Token<'input> {
        "//" => Token::Alt,
        "==" => Token::Equal,
        "!=" => Token::NotEqual,
        "<=" => Token::LessEqual,
        ">=" => Token::GreaterEqual,

        "|" => Token::Pipe,
        "<" => Token::Less,
        ">" => Token::Greater,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Multiply,
        "/" => Token::Divide,
        "%" => Token::Modulo,
        "?" => Token::Question,
        "." => Token::Dot,
        "[" => Token::LeftBracket,
        "]" => Token::RightBracket,
        "{" => Token::LeftBrace,
        "}" => Token::RightBrace,
        "(" => Token::LeftParen,
        ")" => Token::RightParen,
        ":" => Token::Colon,
        ";" => Token::Semicolon,
        "," => Token::Comma,
        "$" => Token::Dollar,

        "and" => Token::And,
        "as" => Token::As,
        "or" => Token::Or,
        "not" => Token::Not,
        "true" => Token::True,
        "false" => Token::False,
        "null" => Token::Null,

        "number" => Token::Number(<&'input str>),
        "string" => Token::String(<&'input str>),
        "ident" => Token::Ident(<&'input str>),
    }
}

// Arranged in order of precedence, lowest (binds looser)
// to highest (binds tighter).

pub Top = Expr;

Expr: Expr<'input> = {
    <value:Expr> "as" "$" <name:"ident"> "|" <expr:PipeExpr> => {
        Expr::Block(name, value.into(), expr.into())
    },
    PipeExpr,
};

PipeExpr: Expr<'input> = {
    <lhs:PipeExpr> "|" <rhs:AltExpr> => Expr::Pipe(lhs.into(), rhs.into()),
    AltExpr,
};

AltExpr: Expr<'input> = {
    <lhs:AltExpr> "//" <rhs:OrExpr> => Expr::Alt(lhs.into(), rhs.into()),
    OrExpr,
};

OrExpr: Expr<'input> = {
    <lhs:OrExpr> "or" <rhs:AndExpr> => Expr::Or(lhs.into(), rhs.into()),
    AndExpr,
};

AndExpr: Expr<'input> = {
    <lhs:AndExpr> "and" <rhs:CompareExpr> => Expr::And(lhs.into(), rhs.into()),
    CompareExpr,
};

CompareExpr: Expr<'input> = {
    <lhs:CompareExpr> "==" <rhs:ArithExpr> => Expr::Equal(lhs.into(), rhs.into()),
    <lhs:CompareExpr> "!=" <rhs:ArithExpr> => Expr::NotEqual(lhs.into(), rhs.into()),
    <lhs:CompareExpr> "<=" <rhs:ArithExpr> => Expr::LessEqual(lhs.into(), rhs.into()),
    <lhs:CompareExpr> ">=" <rhs:ArithExpr> => Expr::GreaterEqual(lhs.into(), rhs.into()),
    <lhs:CompareExpr> "<" <rhs:ArithExpr> => Expr::Less(lhs.into(), rhs.into()),
    <lhs:CompareExpr> ">" <rhs:ArithExpr> => Expr::Greater(lhs.into(), rhs.into()),
    ArithExpr,
};

ArithExpr: Expr<'input> = {
    <lhs:ArithExpr> "+" <rhs:MulExpr> => Expr::Add(lhs.into(), rhs.into()),
    <lhs:ArithExpr> "-" <rhs:MulExpr> => Expr::Subtract(lhs.into(), rhs.into()),
    MulExpr,
};

MulExpr: Expr<'input> = {
    <lhs:MulExpr> "*" <rhs:PrefixExpr> => Expr::Multiply(lhs.into(), rhs.into()),
    <lhs:MulExpr> "/" <rhs:PrefixExpr> => Expr::Divide(lhs.into(), rhs.into()),
    <lhs:MulExpr> "%" <rhs:PrefixExpr> => Expr::Modulo(lhs.into(), rhs.into()),
    PrefixExpr,
};

PrefixExpr: Expr<'input> = {
    "-" <PrefixExpr> => Expr::Negate(<>.into()),
    "not" <PrefixExpr> => Expr::Not(<>.into()),
    PostfixExpr,
};

PostfixExpr: Expr<'input> = {
    <expr:PostfixExpr> "." <key:Ident> => Expr::Index(expr.into(), key.into()),
    <expr:PostfixExpr> "[" <index:AltExpr> "]" => Expr::Index(expr.into(), index.into()),
    <expr:PostfixExpr> "[" <start:AltExpr?> ":" <end:AltExpr?> "]" => {
        Expr::Slice(expr.into(), start.map(Box::new), end.map(Box::new))
    },
    <expr:PostfixExpr> "?" => Expr::Opt(expr.into()),
    Atom,
};

Atom: Expr<'input> = {
    "." => Expr::Identity,
    "$" <"ident"> => Expr::Binding(<>.into()),

    "." <Ident> => Expr::Index(Expr::Identity.into(), <>.into()),

    "(" <Expr> ")" => <>,
    "[" <CommaSeparated<Expr>> "]" => Expr::Array(<>),
    "{" <CommaSeparated<Member>> "}" => Expr::Object(<>),

    <name:"ident"> "(" <args:SemicolonSeparated<Expr>> ")" => Expr::Call(name.into(), args),
    <name:"ident"> => Expr::Call(name.into(), vec![]),

    <start:@L> <n:"number"> <end:@R> =>? Ok(
        Expr::Number(
            n.parse::<Number>().map_err(|err| ParseError::User {
                error: SpannedError {
                    error: err.into(),
                    location: (start, end),
                },
            })?
        )
    ),
    String,
    Bool,
    Null,
};

Member: (Expr<'input>, Expr<'input>) = {
    <key:Ident> ":" <value:Expr> => (key, value),
    "(" <key:Expr> ")" ":" <value:Expr> => (key, value),
    <Ident> => (<>.clone(), Expr::Index(Expr::Identity.into(), <>.into())),
    "$" <"ident"> => (Expr::String(<>.into()), Expr::Binding(<>.into())),
};

String: Expr<'input> = {
    <start:@L> <s:"string"> =>? Ok(
        Expr::String(
            unquote(s).map_err(|err| ParseError::User {
                error: SpannedError {
                    error: LexicalError::BadEscape(err.error),
                    location: (start + err.location.0, start + err.location.1),
                },
            })?
        )
    ),
};

Bool: Expr<'input> = {
    "true" => Expr::Bool(true),
    "false" => Expr::Bool(false),
};

Null: Expr<'input> = {
    "null" => Expr::Null,
};

Ident: Expr<'input> = {
    String,
    Bool,
    Null,
    <start:@L> <n:"number"> <end:@R> =>? Ok(
        Expr::Number(
            n.parse::<Int>()
                .map_err(|err| ParseError::User {
                    error: SpannedError {
                        error: err.into(),
                        location: (start, end),
                    },
                })?
                .into()
        )
    ),
    "ident" => Expr::String(<>.into()),
};

CommaSeparated<T>: Vec<T> = {
    () => vec![],
    <item:T> => vec![item],
    <mut items:CommaSeparated<T>> "," <item:T> => {
        items.push(item);
        items
    }
};

SemicolonSeparated<T>: Vec<T> = {
    () => vec![],
    <item:T> => vec![item],
    <mut items:SemicolonSeparated<T>> ";" <item:T> => {
        items.push(item);
        items
    }
};
